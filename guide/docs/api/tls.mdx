---
id: tls
title: TLS
sidebar_label: TLS
slug: /api/tls
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

[Modbus Security](https://modbus.org/docs/MB-TCP-Security-v21_2018-07-24.pdf) is a specification to wrap Modbus TCP inside a TLS secure transport to enable authentication
and privacy of the communication links. It uses an X.509v3 extension to provide an authorization mechanism on the server. The IANA reserved port for Modbus Security is 802.

In the presented certificate, the client must provide an x.509v3 extension with OID `1.3.6.1.4.1.50316.802.1`
containing an `ASN1:UTF8String`. This arbitrary string represents the authorized role of the client and is
used to authorize operations. For example, a client with the `historian` role might only be allowed to read
a certain range of values, while a client with the `operator` role might be able to write coils and registers.

```mermaid
sequenceDiagram
Client->Server: TLS handshake
Client->>Server: Modbus request
Server->>Authorization Handler: Check authorization
alt authorized
Authorization Handler->>Server: AUTHORIZED
Server->>Point Database: Execute operation
Point Database->>Server: Response
Server->>Client: Response
else not authorized
Authorization Handler->>Server: NOT_AUTHORIZED
Server->>Client: Illegal function code exception
end
```

The library internally uses [rustls](https://github.com/rustls/rustls), a modern TLS library entirely written in Rust. Therefore, it does **not** depend on OpenSSL
or other third-party library that needs to be present on the system, but will interoperate with peers using these libraries.

## Supported features

- TLS v1.2 and v1.3
- Supported cipher suites (in descending order of preference):
  - TLS v1.3:
    - `TLS_CHACHA20_POLY1305_SHA256`
    - `TLS_AES_256_GCM_SHA384`
    - `TLS_AES_128_GCM_SHA256`
  - TLS v1.2:
    - `TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256`
    - `TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256`
    - `TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384`
    - `TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256`
    - `TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384`
    - `TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256`
- Supported key exchange groups (in descending order of preference):
  - `x25519`
  - `secp384r1`
  - `secp256r1`
- Supported signature hash algorithms (in descending order of preference):
  - `ecdsa_secp384r1_sha384`
  - `ecdsa_secp256r1_sha256`
  - `ed25519` (v1.3 only)
  - `rsa_pss_sha512` (v1.3 only)
  - `rsa_pss_sha384` (v1.3 only)
  - `rsa_pss_sha256` (v1.3 only)
  - `rsa_pkcs1_sha512`
  - `rsa_pkcs1_sha384`
  - `rsa_pkcs1_sha256`
- Server name validation through SAN and Common Name.
- Self-signed certificates (with a special configuration)

## Configuration

TLS configuration is done through the `TlsClientConfig` and `TlsServerConfig` structures. They are both very similar.
The fields are the following:

- `name` (client only): requested server DNS name. The client will advertise this name through
  a Server Name Indication (SNI) extension in the `Client Hello`. The client will verify that
  the presented certificate is valid for this DNS name. is valid for this DNS name. See the
  following section for more details about name validation. DNS name validation is not performed
  when `CertificateMode` is `SelfSignedCertificate`.
- `peer_cert_path`: path to the unencrypted PEM file containing the trusted
  root certificate(s) or the peer self-signed certificate.
- `local_cert_path`: path to the unencrypted PEM file containing the certificate
  or the chain of certificates to present to the peer.
- `private_key_path`: path to the PEM file containing the private
  key of the local certificate.
- `password`: password used to decrypt the private key file. Leave empty if the file
  is not encrypted. See the next section for more details.
- `min_tls_version`: minimum TLS version to support. Setting this to `Tls1_3`
  will force TLSv1.3.
- `certificate_mode`: mode of verification of the presented certificate. See
  the next section for more details.

### Name validation

The client always validates the server name when `certificate_mode` is `TrustChain`.

A valid name has the same requirements as a DNS name. This is defined in
[RFC 1034 Section 3.5](https://datatracker.ietf.org/doc/html/rfc1034#section-3.5),
updated by [RFC1123 Section 2.1](https://datatracker.ietf.org/doc/html/rfc1123#section-2),
with the additional exception that underscores `_` are allowed. A brief (but incomplete)
definition of a valid name would be the following:

- One or more labels separated by a single period
- Labels are made of alphanumeric characters `[A-Za-z0-9]`, hyphen `-` and underscores `_`
- A label cannot start or end with an hyphen `-`
- A label cannot be all numeric
- A label cannot be empty
- Maximum of 63 characters per label
- Maximum of 253 characters total

We first validate the name through the Subject Alternative Name (SAN) extension if it's present.
The SAN can contain multiple names and each name can contain a wildcard `*` character. The comparison
is case insensitive.

If and only if no SAN extension is present, then the Common Name from the certificate's Subject
is extracted and compared. The Common Name cannot contain a wildcard character and the comparison
is case sensitive. It is effectively compared byte-for-byte with the expected name.

:::note
Using SAN is the recommended way as Common Name usage is deprecated
and might be removed in the future. New certificates should provide name
in a SAN extension.
:::

### Private key encryption

Unencrypted private keys can be stored in PKCS#8 (`-----BEGIN PRIVATE KEY-----`) or
PKCS#1 format (`----BEGIN RSA PRIVATE KEY-----`).

Encrypted private keys **must** be stored in PKCS#8v2 (`-----BEGIN ENCRYPTED PRIVATE KEY-----`).
PKCS#1 encryption is **not** supported. The following algorithms are supported:

- Key derivation functions:
  - scrypt (RFC 7914) **recommended**
  - PBKDF2 (RFC 8018) SHA-2 based PRF with HMAC-SHA224, HMAC-SHA256, HMAC-SHA384, or HMAC-SHA512
- Symmetric encryption:
  - AES-128-CBC
  - AES-192-CBC
  - AES-256-CBC **recommended**

Notable unsupported algorithms are all SHA-1 based key derivation and DES/3DES symmetric encryption.
These are considered insecure and should not be used anymore.

[OpenSSL `pkcs8`](https://www.openssl.org/docs/man1.1.1/man1/openssl-pkcs8.html) tool can help you
encrypting or converting private keys.

:::warning
Encrypting private keys is not an automatic security guarantee. Proper access control should be prioritized
before encrypting the private the key. Keep in mind that encrypting a private key and leaving the password
somewhere not-so-private (e.g. in the source code of your application) is the equivalent of locking the doors
of your home and leaving a key in the mailbox.
:::

### Certificate mode

The `certificate_mode` parameter determines how the presented peer certificate
will be validated.

The default `TrustChain` value validates that the presented chain of certificates
and verify that the root certificate of the chain is one of those provided in
the `peer_cert_path` file. In the power industry, we recommend having a **single**
root certificate. It also validates that all critical extensions are handled, the
time validity, the DNS name (only the clients validate the name) and other details.
It will **not** accept self-signed certificate.

The `SelfSignedCertificate` value validates that only a single certificate is
presented and that it matches byte-for-byte the configured `peer_cert_path`. It
also checks the time validity using the system clock. Since the number of checks
is limited, a **thorough manual inspection of the configured self-signed certificate is
required beforehand**. Also note that the DNS name is **not** verified with this mode,
as this check should be performed manually before adding the self-signed certificate
to the configuration.

### `AuthorizationHandler`

When creating a Modbus Security server, you also need to provide an `AuthorizationHandler`.
It is use to validate that the client has the authorization to perform the operation. There's
a callback for each function code. You get the unit ID of the destination, information about
what points are requested (either as an `AddressRange` or a 16-bit unsigned integer) as well as
the Role ID that was extracted from the presented certificate.

If your handler returns `AuthorizationResult::Authorized`, then the request is passed to
the appropriate handler and the operation is performed. If your handler returns
`AuthorizationResult::NotAuthorized`, then the request is dropped and an `Illegal function code`
exception is returned to the client.

## Generating certificates

The following commands are provided as a guideline to generate certificates using the
OpenSSL command line interface.

### CA trust chain

:::warning
You should probably use an actual CA software instead of manually generating these certificates.
These commands are provided for testing purposes.
:::

- Generate the root CA certificate: `openssl req -x509 -newkey rsa:4096 -keyout ./ca_key.pem -out ./ca_cert.pem -subj "/C=US/ST=Oregon/L=Bend/O=Test/CN=DO NOT USE" -nodes -days 3650`
- Generate the client CSR: `openssl req -new -newkey rsa:4096 -keyout ./client_key.pem -out ./client_csr.pem -subj "/C=US/ST=Oregon/L=Bend/O=Test/CN=DO NOT USE" -addext "1.3.6.1.4.1.50316.802.1=ASN1:UTF8String:operator" -nodes -days 365`
- Generate the client certificate: `openssl x509 -req -days 365 -in ./client_csr.pem -extfile <(printf "1.3.6.1.4.1.50316.802.1=ASN1:UTF8String:operator") -CA ./ca_cert.pem -CAkey ./ca_key.pem -set_serial 1 -out ./client_cert.pem -sha256`
- Generate the server CSR: `openssl req -new -newkey rsa:4096 -keyout ./server_key.pem -out ./server_csr.pem -subj "/C=US/ST=Oregon/L=Bend/O=Test/CN=DO NOT USE" -addext "subjectAltName=DNS:test.com" -nodes -days 365`
- Generate the server certificate: `openssl x509 -req -days 365 -in ./server_csr.pem -extfile <(printf "subjectAltName=DNS:test.com") -CA ./ca_cert.pem -CAkey ./ca_key.pem -set_serial 2 -out ./server_cert.pem -sha256`

### Self-signed certificate

- Generate the client certificate: `openssl req -x509 -newkey rsa:4096 -keyout ./client_key.pem -out ./client_cert.pem -subj "/C=US/ST=Oregon/L=Bend/O=Test/CN=DO NOT USE" -addext "1.3.6.1.4.1.50316.802.1=ASN1:UTF8String:operator" -nodes -days 365`
- Generate the server certificate: `openssl req -x509 -newkey rsa:4096 -keyout ./server_key.pem -out ./server/entity2_cert.pem -subj "/C=US/ST=Oregon/L=Bend/O=Test/CN=DO NOT USE" -addext "subjectAltName=DNS:test.com" -nodes -days 365`
