---
id: tls
title: TLS
sidebar_label: TLS
slug: /api/tls
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

[Modbus Security](https://modbus.org/docs/MB-TCP-Security-v21_2018-07-24.pdf) is a specification to wrap Modbus TCP inside a TLS secure transport to enable authentication
and privacy of the communication links. It uses an X.509v3 extension to provide an authorization mechanism on the server. The IANA reserved port for Modbus Security is 802.

In the presented certificate, the client must provide an x.509v3 extension with OID `1.3.6.1.4.1.50316.802.1`
containing an `ASN1:UTF8String`. This arbitrary string represents the authorized role of the client and is
used to authorize operations. For example, a client with the `historian` role might only be allowed to read
a certain range of values, while a client with the `operator` role might be able to write coils and registers.

```mermaid
sequenceDiagram
Client->Server: TLS handshake
Client->>Server: Modbus request
Server->>Authorization Handler: Check authorization
alt authorized
Authorization Handler->>Server: AUTHORIZED
Server->>Point Database: Execute operation
Point Database->>Server: Response
Server->>Client: Response
else not authorized
Authorization Handler->>Server: NOT_AUTHORIZED
Server->>Client: Illegal function code exception
end
```

The library internally uses [rustls](https://github.com/rustls/rustls), a modern TLS library entirely written in Rust. Therefore, it does **not** depend on OpenSSL
or other third-party library that needs to be present on the system, but will interoperate with peers using these libraries.

## Supported features

- TLS v1.2 and v1.3
- Supported cipher suites (in descending order of preference):
  - TLS v1.3:
    - `TLS_CHACHA20_POLY1305_SHA256`
    - `TLS_AES_256_GCM_SHA384`
    - `TLS_AES_128_GCM_SHA256`
  - TLS v1.2:
    - `TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256`
    - `TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256`
    - `TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384`
    - `TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256`
    - `TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384`
    - `TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256`
- Supported key exchange groups (in descending order of preference):
  - `x25519`
  - `secp384r1`
  - `secp256r1`
- Supported signature hash algorithms (in descending order of preference):
  - `ecdsa_secp384r1_sha384`
  - `ecdsa_secp256r1_sha256`
  - `ed25519` (v1.3 only)
  - `rsa_pss_sha512` (v1.3 only)
  - `rsa_pss_sha384` (v1.3 only)
  - `rsa_pss_sha256` (v1.3 only)
  - `rsa_pkcs1_sha512`
  - `rsa_pkcs1_sha384`
  - `rsa_pkcs1_sha256`
- Self-signed certificates (with a special configuration)

## Configuration

TLS configuration is done through the `TlsClientConfig` and `TlsServerConfig` structures. They are both very similar.
The fields are the following:

- `name` (client only): requested server DNS name. The client will advertise this name through
  a Server Name Indication (SNI) extension in the `Client Hello`. The client will verify that
  the presented certificate is valid for this DNS name. Since Common Name is deprecated, the
  presented certificate **must** have the DNS name appear in in a Subject
  Alternative Name (SAN) extension. DNS name validation is not performed
  when `CertificateMode` is `SelfSignedCertificate`.
- `peer_cert_path`: path to the unencrypted PEM file containing the trusted
  root certificate(s) or the peer self-signed certificate.
- `local_cert_path`: path to the unencrypted PEM file containing the certificate
  or the chain of certificates to present to the peer.
- `private_key_path`: path to the unencrypted PEM file containing the private
  key of the local certificate.
- `min_tls_version`: minimum TLS version to support. Setting this to `Tls1_3`
  will force TLSv1.3.
- `certificate_mode`: mode of verification of the presented certificate. See
  the next section for more details.

### Certificate mode

The `certificate_mode` parameter determines how the presented peer certificate
will be validated.

The default `TrustChain` value validates that the presented chain of certificates
and verify that the root certificate of the chain is one of those provided in
the `peer_cert_path` file. In the power industry, we recommend having a **single**
root certificate. It also validates that all critical extensions are handled, the
time validity, the DNS name (only the clients validate the name) and other details.
It will **not** accept self-signed certificate.

The `SelfSignedCertificate` value validates that only a single certificate is
presented and that it matches byte-for-byte the configured `peer_cert_path`. It
also checks the time validity using the system clock. Since the number of checks
is limited, a **thorough manual inspection of the configured self-signed certificate is
required beforehand**. Also note that the DNS name is **not** verified with this mode,
as this check should be performed manually before adding the self-signed certificate
to the configuration.

### `AuthorizationHandler`

When creating a Modbus Security server, you also need to provide an `AuthorizationHandler`.
It is use to validate that the client has the authorization to perform the operation. There's
a callback for each function code. You get the unit ID of the destination, information about
what points are requested (either as an `AddressRange` or a 16-bit unsigned integer) as well as
the Role ID that was extracted from the presented certificate.

If your handler returns `AuthorizationResult::Authorized`, then the request is passed to
the appropriate handler and the operation is performed. If your handler returns
`AuthorizationResult::NotAuthorized`, then the request is dropped and an `Illegal function code`
exception is returned to the client.

## Generating certificates

The following commands are provided as a guideline to generate certificates using the
OpenSSL command line interface.

### CA trust chain

:::warning
You should probably use an actual CA software instead of manually generating these certificates.
These commands are provided for testing purposes.
:::

- Generate the root CA certificate: `openssl req -x509 -newkey rsa:4096 -keyout ./ca_key.pem -out ./ca_cert.pem -subj "/C=US/ST=Oregon/L=Bend/O=Test/CN=DO NOT USE" -nodes -days 3650`
- Generate the client CSR: `openssl req -new -newkey rsa:4096 -keyout ./client_key.pem -out ./client_csr.pem -subj "/C=US/ST=Oregon/L=Bend/O=Test/CN=DO NOT USE" -addext "1.3.6.1.4.1.50316.802.1=ASN1:UTF8String:operator" -nodes -days 365`
- Generate the client certificate: `openssl x509 -req -days 365 -in ./client_csr.pem -extfile <(printf "1.3.6.1.4.1.50316.802.1=ASN1:UTF8String:operator") -CA ./ca_cert.pem -CAkey ./ca_key.pem -set_serial 1 -out ./client_cert.pem -sha256`
- Generate the server CSR: `openssl req -new -newkey rsa:4096 -keyout ./server_key.pem -out ./server_csr.pem -subj "/C=US/ST=Oregon/L=Bend/O=Test/CN=DO NOT USE" -addext "subjectAltName=DNS:test.com" -nodes -days 365`
- Generate the server certificate: `openssl x509 -req -days 365 -in ./server_csr.pem -extfile <(printf "subjectAltName=DNS:test.com") -CA ./ca_cert.pem -CAkey ./ca_key.pem -set_serial 2 -out ./server_cert.pem -sha256`

### Self-signed certificate

- Generate the client certificate: `openssl req -x509 -newkey rsa:4096 -keyout ./client_key.pem -out ./client_cert.pem -subj "/C=US/ST=Oregon/L=Bend/O=Test/CN=DO NOT USE" -addext "1.3.6.1.4.1.50316.802.1=ASN1:UTF8String:operator" -nodes -days 365`
- Generate the server certificate: `openssl req -x509 -newkey rsa:4096 -keyout ./server_key.pem -out ./server/entity2_cert.pem -subj "/C=US/ST=Oregon/L=Bend/O=Test/CN=DO NOT USE" -addext "subjectAltName=DNS:test.com" -nodes -days 365`
